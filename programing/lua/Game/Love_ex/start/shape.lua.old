require "collison"
local Matrix = require "matrix"

local function vect_len( v )
  return math.sqrt( v[1][1]^2 + v[2][1]^2 )
end

Shape = {}

setmetatable(Shape
    , { __call =  function (o, vertices)
    return o:new(vertices) end
    })

function Shape:new( vertices ) 
  local o = {}
  setmetatable( o, {__index = self})
  o.mat = Matrix.new( vertices ) 
  o.color = {1, 1, 1, 1}
  o.action = "fill"
  return o
end

function Shape:move( x_inc, y_inc )
  shiftx = x_inc * Matrix.ones(1, #self.mat[1])
  shifty = y_inc * Matrix.ones(1, #self.mat[1])
  self.mat = self.mat + Matrix.new( { shiftx[1], shifty[1] } )
end

function Shape:getCentroid( )
  local r, c = Matrix.size(self.mat)
  local xsum = 0
  local ysum = 0
  for i = 1, c, 1 do
    xsum = xsum + self.mat[1][i]
    ysum = ysum + self.mat[2][i]
  end
  return xsum/c, ysum/c
end

function Shape:moveto( x, y )
  local center_x, center_y = self:getCentroid()
  local shiftx = (x - center_x) * Matrix.ones(1, #self.mat[1])
  local shifty = (y - center_y)* Matrix.ones(1, #self.mat[1])
  self.mat = self.mat + Matrix.new( { shiftx[1], shifty[1] } )
end

function Shape:setColor( rgba )
  self.color = rgba
end

function Shape:getColor()
  return self.color
end

function Shape:getAction()
  return self.action
end

function Shape:getType()
  return "Polygon"
end

function Shape.isOverlaped( ax, a, b )
  local r, c, projA, projB
  r, c = Matrix.size(a)
  projA = Matrix.transpos(ax) * a
  sortedA = Matrix.sort( projA )
  projB = Matrix.transpos(ax) * b 
  sortedB = Matrix.sort( projB )
  local last = #projA[1]
  for i = 1, #projB[1], 1 do
    if projB[1][i] > sortedA[1][1] and projB[1][i] < sortedA[1][last] then
      return true, i
    end
  end
  last = #projB[1]
  for i = 1, #projA[1], 1 do
    if projA[1][i] > sortedB[1][1] and projA[1][i] < sortedB[1][last] then
      return true, i
    end
  end
  return false, -1
end

function Shape.SAT(a, b)
  local r, c = Matrix.size(a)
  local ax, result, overlapPt
  for i = 1, c, 1 do
    if i == c then
      ax = Matrix.new({{0, -1},{1, 0}}) 
          * ( Matrix.col(a, i) - Matrix.col(a, 1) )
    else
      ax = Matrix.new({{0, -1},{1, 0}}) 
          * ( Matrix.col(a, i) - Matrix.col(a, i+1) )
    end
    result, overlapPt = Shape.isOverlaped(ax, a, b)
    if result == false then
      return false, -1 
    end
  end
  r, c = Matrix.size(b)
  for i = 1, c, 1 do
    if i == c then
      ax = Matrix.new({{0, -1},{1, 0}}) 
          * ( Matrix.col(b, i) - Matrix.col(b, 1) )
    else
      ax = Matrix.new({{0, -1},{1, 0}}) 
          * ( Matrix.col(b, i) - Matrix.col(b, i+1) )
    end
    result = Shape.isOverlaped(ax, b, a)
    if result == false then
      return false, -1
    end
  end
  return true, overlapPt
end

function Shape.pt2ptSort(pt, mat)
  local c = #mat[1]
  local ptsLen = {math.huge, math.huge}
  local pts ={}
  for i = 1, c, 1 do
    ptsLen[i] = ( pt[1][1] - mat[1][i] )^2 + ( pt[2][1] - mat[2][i] )^2
    pts[i] = i
  end
  -- 거리 순서로 sorting
  for i = 1, c, 1 do
    for j = i+1, c, 1 do
      if ptsLen[i] > ptsLen[j] then
        local tmp = ptsLen[i]
        ptsLen[i] = ptsLen[j]
        ptsLen[j] = tmp 
        tmp = pts[i]
        pts[i] = pts[j]
        pts[j] = tmp
      end
    end
  end
  return ptsLen, pts
end

function Shape.vertice2vectorDist( vect, vertices)
  local ax = Matrix.col(vect, 2) - Matrix.col(vect, 1)
  local len = vect_len( ax ) 
  local norm = (1/len)*ax
  local w = vertices - Matrix.col(vect, 1)
  len = Matrix.transpos(w) * norm
  -- caculate orthogonal vector
  local ortho = w - len*norm
  return ( ortho[1][1]^2 + ortho[2][1]^2 ), ortho
end

local function find_collision_pt(a, b)
  local pt = -1
  for i = 1, #a[1], 1 do
    local col = Matrix.col(a, i)
    col = Matrix.join(col, col)
    local ret = collisonTest( col, b) 
    if ret then
      pt = i
      break
    end
  end
  return pt
end

local function gen_adjacent_vect(vect, col)
  if vect[1] == col then
    vect[2] = 1
  else
    vect[2] = vect[1] + 1
  end
  if vect[1] == 1 then
    vect[3] = col
  else
    vect[3] = vect[1] - 1
  end
  return vect 
end

local function find_boundary( adjA, matA, adjB, matB )
  local A12 = Matrix.col( matA, adjA[1] ) 
  A12 = Matrix.join( A12, Matrix.col( matA, adjA[2] ) )
  local A13 = Matrix.col( matA, adjA[1] ) 
  A13 = Matrix.join( A13, Matrix.col( matA, adjA[3] ) )

  local B12 = Matrix.col( matB, adjB[1] ) 
  B12 = Matrix.join( B12, Matrix.col( matB, adjB[2] ) )
  local B13 = Matrix.col( matB, adjB[1] ) 
  B13 = Matrix.join( B13, Matrix.col( matB, adjB[3] ) )

--[[
  print( "A12: " )
  print( A12)
  print( "A13: " )
  print( A13)
--]]
  local A12norm = Matrix.col(A12, 2) - Matrix.col(A12, 1)
  local len = math.sqrt( A12norm[1][1]^2 + A12norm[2][1]^2 )
--[[
  print( "A12norm: " )
  print( A12norm )
--]]
  A12norm = (1/len) * A12norm
  local A13norm = Matrix.col(A13, 2) - Matrix.col(A13, 1)
  len = math.sqrt( A13norm[1][1]^2 + A13norm[2][1]^2 )
--[[
  print( "A13norm: " )
  print( A13norm )
--]]
  A13norm = (1/len) * A13norm
  local B12norm = Matrix.col(B12, 2) - Matrix.col(B12, 1)
  len = math.sqrt( B12norm[1][1]^2 + B12norm[2][1]^2 )
  B12norm = (1/len) * B12norm
  local B13norm = Matrix.col(B13, 2) - Matrix.col(B13, 1)
  len = math.sqrt( B13norm[1][1]^2 + B13norm[2][1]^2 )
  B13norm = (1/len) * B13norm
  local A12cos = Matrix.transpos( A12norm ) * B12norm
  local A13cos = Matrix.transpos( A13norm ) * B12norm
  local Aadj, B12cos
  if A12cos > A13cos then
    B12cos = A12cos
    Aadj = A12norm
  else
    B12cos = A13cos
    Aadj = A13norm
  end

  --[
  local lenB12, orthoB12
    = Shape.vertice2vectorDist( B12, Matrix.col( A12, 1) )
  local lenB13, orthoB13
    = Shape.vertice2vectorDist( B13, Matrix.col( A12, 1) )
  if math.abs( lenB12 - lenB13 ) > 0.001 then
    if lenB12 <= lenB13 then
      return B12, B13
    else
      return B13, B12
    end
  end
  --]]

--[[
  print( "B12norm: " )
  print( B12norm )
  print( "B13norm: " )
  print( B13norm )
  print( "Aadj: " )
  print( Aadj )
--]]
  local B13cos = Matrix.transpos( B13norm ) * Aadj
  -- print( B12cos, B13cos)
  if B12cos > B13cos then
    return B12
  else
    return B13
  end
end

local function check_segment_intersection( A, B )
  -- scale up for preventing roundoff erro
  local A1 = 100*Matrix.col( A, 1 )
  local A2 = 100*Matrix.col( A, 2 )
  local B1 = 100*Matrix.col( B, 1 )
  local B2 = 100*Matrix.col( B, 2 )
  local A12 = A2 - A1
  local B12 = B2 - B1
  local A1B1 = B1 -A1
  local A1B2 = B2 - A1
  local B1A1 = A1 - B1
  local B1A2 = A2 - B1

  local A12B1 = A12[1][1]*A1B1[2][1] - A12[2][1]*A1B1[1][1]
  local A12B2 = A12[1][1]*A1B2[2][1] - A12[2][1]*A1B2[1][1]

  local B12A1 = B12[1][1]*B1A1[2][1] - B12[2][1]*B1A1[1][1]
  local B12A2 = B12[1][1]*B1A2[2][1] - B12[2][1]*B1A2[1][1]
--[[
  print( " A - A': " )
  print( A )
  print( " adjB12: " )
  print( B )
  print( "A12B1, A12B2", A12B1, A12B2)
  print( "B12A1, B12A2", B12A1, B12A2)
  --]]

  
  if ( A12B1 * A12B2  <= 0 ) and ( B12A1 * B12A2 <= 0 ) then
    return true, B12A1*B12A2
  end
  return false, B12A1*B12A2
end


-- A : moving body
-- B : station body
-- return : dx, dy
local function resolve_edge_condition(A, B, idxA, idxB, dx, dy)
  local adjA = { idxA }
  local adjB = { idxB }
  gen_adjacent_vect( adjA, #A[1] )
  gen_adjacent_vect( adjB, #B[1] )
  local A1 = Matrix.col(A, adjA[1])
  local A2 = Matrix.col(A, adjA[2])
  local A3 = Matrix.col(A, adjA[3])
  local B1 = Matrix.col(B, adjB[1])
  local B2 = Matrix.col(B, adjB[2])
  local B3 = Matrix.col(B, adjB[3])

  -- 겹치는 두 점 사이의 vector를 구한다.
  local adj
  -- scale up to prevent roundoff error
  local vectAB = 100*B1 - 100*A1
  vectAB = (1/100)*vectAB

  -- 인접한 두 점이 아니다. 따로 처리가 필요하지 않다.
  if math.sqrt(vectAB[1][1]^2 + vectAB[2][1]^2) > 0.01 then 
    return Matrix.new( { {-dx}, {-dy} } ), false
  end

  -- A - A(dx, dy) vector와 B의 인접 segment들과 교차점이 있는지 조사한다.
  --[
  -- displacement vector
  local dxdy = Matrix.new({
      {A1[1][1] - dx, A1[1][1]}
    , {A1[2][1] - dy, A1[2][1]}
  })
  local segmentB12 = Matrix.new({
      { B1[1][1], B2[1][1] }
    , { B1[2][1], B2[2][1]}
  })
  local segmentB13 = Matrix.new({
      { B1[1][1], B3[1][1] }
    , { B1[2][1], B3[2][1]}
  })
  local is_intersect, angle = check_segment_intersection( dxdy, segmentB12 )
  if  is_intersect then
    adj = Matrix.join( B1, B2 ) 
  else 
    is_intersect, angle = check_segment_intersection( dxdy, segmentB13 )
    if is_intersect then
      adj = Matrix.join( B1, B3 ) 
    end
  end
  local dist, ds 
  if angle == 0 then
    ds = 100*B1 - 100*A1
    ds = 1/100*ds
    return ds, true
  end
  -- print( adj )

  if adj == nil then
    return Matrix.new( { {-dx}, {-dy} } ), false
  end

  dist, ds 
    = Shape.vertice2vectorDist( adj, A1 )

  return -1*ds, true
end


function Shape:resolve( dx, dy, obj )
  --[ prevent tunneling 
  if (dx*dx + dy*dy) > 0.1 then
    self:move( -dx, -dy )
    return Matrix.new( { {0}, {0} })
  end
  --]]
  if self:getType() == "Circle" then
    return nil
  end
  if obj:getType() == "Circle" then
    return nil
  end
  
  local ax = Matrix.new( {
    {  dx }
    ,{ dy }
  })

  local dist, sortedPtsA
  local sortedPtsB
  local boundary, nearest_pt
  local pt = find_collision_pt(self.mat, obj.mat)
  local sign = 1
  if pt < 0 then
    pt = find_collision_pt(obj.mat, self.mat)
    sortedPtsB = {pt}
    if pt < 0 then
      self:move( -dx, -dy )
      return
    end
    self:move( -dx, -dy )
    local col = Matrix.col(obj.mat, pt)
    dist, sortedPtsA = Shape.pt2ptSort(col, self.mat)
    gen_adjacent_vect( sortedPtsA, #self.mat[1] )
    gen_adjacent_vect( sortedPtsB, #obj.mat[1] )
    nearest_pt = Matrix.new( { {obj.mat[1][pt]},{obj.mat[2][pt]} } )
    boundary = find_boundary( sortedPtsB, obj.mat, sortedPtsA, self.mat )
    sign = -1
  else
    sortedPtsA = {pt}
    pt = find_collision_pt(obj.mat, self.mat)
    if pt > 0 then
      local ds, is_edge = resolve_edge_condition( 
         self.mat
        ,obj.mat
        ,sortedPtsA[1], pt
        ,dx, dy 
      ) 
      self:move( ds[1][1], ds[2][1] )
      --[[
      print(" edge condition " )
      print( ds[1][1], ds[2][1] )
      --]]
      if is_edge then
        return ds 
      end
    end
    pt = sortedPtsA[1]
    self:move( -dx, -dy )
    local col = Matrix.col(self.mat, pt)
    dist, sortedPtsB = Shape.pt2ptSort( col, obj.mat)
    gen_adjacent_vect( sortedPtsA, #self.mat[1] )
    gen_adjacent_vect( sortedPtsB, #obj.mat[1] )
    nearest_pt = Matrix.new( { {self.mat[1][pt]},{self.mat[2][pt]} } )
    boundary = find_boundary( sortedPtsA, self.mat, sortedPtsB, obj.mat )
  end
  dist, ortho
    = Shape.vertice2vectorDist(boundary, nearest_pt) 
--[[
  print( " dist: ")
  print( dist )
  print( " ortho: ")
  print( ortho )
--]]
  boundary = Matrix.col(boundary, 2) - Matrix.col(boundary, 1)
  len = vect_len( boundary )
  local norm = (1/len) * boundary
  norm = Matrix.transpos( Matrix.new({{dx},{dy}}) ) * norm * norm
  shift = sign * ortho - norm 
  
  shift = Matrix.new({
     ( shift[1][1] * Matrix.ones(1, #self.mat[1]) )[1]
    ,( shift[2][1] * Matrix.ones(1, #self.mat[1]) )[1]
    
  })
  self.mat = self.mat - shift 
  return shift 
end

function Shape:is_collieded( o )
  if o:getType() == "Polygon" then
    return Shape.SAT( self.mat, o.mat )
  end
  if o:getType() == "Circle" then
    return o:is_collieded(self)
  end
end

function Shape:draw( scene )
  love.graphics.setColor( self.color )
  love.graphics.polygon( self.action, self:getVertices( scene, self.mat ) )
end

function Shape:getVertices( scene , m)
  local r, c = Matrix.size( m)
  local v = { }
  local k = 1
  for i = 1, c, 1 do
    -- v[k] : x coordinate, v[k+1] : y coordinate
    v[k], v[k+1] = scene:scene2screen( m[1][i], m[2][i] )
    k = k + 2
  end
  return v
end

function Shape:__tostring()
  return tostring(self.mat)
end
